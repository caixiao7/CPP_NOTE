Part1：

智能指针：

auto ptr已经废掉，不讨论

unique ptr不可传递

share ptr可以作为右值赋值给新的share ptr，内部通过引用计数，自动释放指针。

 

使用share ptr时，注意循环引用（这种情况与死锁相似），两个类都有share ptr成员变量分别指向对方，如果两个类的对象互相引用，将导致离开作用域时，无法删除share ptr。

此时应该将其中一个类中的变量声明为weak ptr，这样运行时，离开作用域，C++便可以释放这两个对象。

使用weak ptr需要注意，每次使用这个引用时，需要用lock()函数，确保此对象没有被释放，如果返回nullptr，说明对象已经释放。

 

谈到死锁，重温一下避免死锁的方法：（死锁是两个线程，或者进程，分别持有A、B两个独占资源，而且都在申请B、A，双方都不释放，导致死锁）

申请锁的顺序写死，例如两个线程都按A、B的顺序申请锁，坏处是无法提前知道需要何种锁
试探性加锁，需要维护一张每个线程或者进程已经申请锁的列表，试探性加锁后，通过检查列表，提前发现是否存在死锁条件。
加入申请锁的时限。对应于C++11的try lock
 

再谈谈race condition，所谓竞争状态，就是两个线程，同时操作共享变量，由于读写变量不具备原子操作性。

避免方法，使用线程原子性原语，或者通过加关键段mutex等避免